(function(f,x){typeof exports=="object"&&typeof module<"u"?module.exports=x(require("axios"),require("lodash"),require("mobx"),require("uuid"),require("crypto-js")):typeof define=="function"&&define.amd?define(["axios","lodash","mobx","uuid","crypto-js"],x):(f=typeof globalThis<"u"?globalThis:f||self,f["arm-js-library"]=x(f.axios,f._,f.mobx,f.uuid,f.CryptoJS))})(this,function(f,x,us,L,ls){"use strict";function fs(O){const s=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(O){for(const e in O)if(e!=="default"){const t=Object.getOwnPropertyDescriptor(O,e);Object.defineProperty(s,e,t.get?t:{enumerable:!0,get:()=>O[e]})}}return s.default=O,Object.freeze(s)}const ps=fs(us);/**
 * ARM JavaScript Library
 *
 * Version: 1.5.1
 * Date: 2024-05-09 2:19PM GMT+8
 *
 * @author Michael Jyms Gutierrez
 * @license MIT
 *
 * Axios library for making HTTP requests.
 * @see https://axios-http.com/docs/
 *
 * Lodash utility library.
 * @see https://lodash.com/docs/4.17.21
 *
 * MobX state management library.
 * @see https://mobx.js.org/
 *
 * UUID generation library.
 * @see https://www.npmjs.com/package/uuid
 *
 * CryptoJS library for cryptographic functions.
 * @see https://crypto-js.org/
 */const{makeObservable:Is,observable:v,action:E,toJS:F}=ps,{get:i,set:n,find:m,findIndex:g,isObject:ys,isArray:y,isPlainObject:I,isNumber:z,isString:_s,isNull:ss,isNil:_,isEmpty:w,isEqual:p,gte:b,gt:qs,lte:ms,lt:U,assign:gs,flatMap:bs,map:D,entries:Rs,forEach:l,filter:es,keysIn:N,concat:js,chunk:Hs,uniqWith:Os,omit:k,first:G,last:ts,orderBy:Cs,uniqBy:Ps,groupBy:As}=x,is={isLoading:!0,isError:!1,isNew:!0,data:[],included:[],meta:{}},J={isLoading:!0,isError:!1,isNew:!0,data:{},included:[],meta:{}},M=["destroyRecord","getCollection","reload","save","set","get","setProperties","isDirty","isError","isLoading","isPristine"],xs=["destroyRecord","getCollection","reload","save","set","get","setProperties","isDirty","isError","isLoading","isPristine","hashId","collectionName"];class ws{constructor(s=[]){this.namespace="api/v1",this.host=typeof window<"u"?window.location.origin:"",this.collections={},this.aliases={},this.requestHashIds={},this.payloadIncludedReference="type",this._initializeCollections(s),this._initializeAxiosConfig(),Is(this,{collections:v,aliases:v,requestHashIds:v,_pushPayload:E,_pushRequestHash:E,_addCollection:E,_addAlias:E})}_initializeAxiosConfig(){f.defaults.baseURL=this._getBaseURL()}_initializeCollections(s){l(s,e=>this._addCollection(e,[]))}_getBaseURL(){return`${this.host}/${this.namespace}`}_isCollectionExisting(s){if(_(i(this.collections,s)))throw`Collection ${s} does not exist.
Fix: Try adding ${s} on your ARM config initialization.`}_addCollection(s,e){this.collections[s]=e}_addAlias(s,e){const t=y(e),o=I(e);t&&(this.aliases[s]=e||[]),o&&(this.aliases[s]=e||{})}_generateHashId(s={id:L.v1()}){const e=JSON.stringify(s);return ls.MD5(e).toString()}_getProperty(s){return i(this,s)}_setProperty(s,e){n(this,s,e);const t=k(F(this.originalRecord),M),o=k(F(this),M);p(t,o)?(n(this,"isDirty",!1),n(this,"isPristine",!0)):(n(this,"isDirty",!0),n(this,"isPristine",!1))}_setProperties(s){function e(a,c=""){return bs(Rs(a),([h,u])=>{const q=c?`${c}.${h}`:h;return ys(u)&&!y(u)&&u!==null?e(u,q):{key:q,value:u}})}const t=e(s);l(t,({key:a,value:c})=>n(this,a,c));const o=k(F(this.originalRecord),M),r=k(F(this),M);p(o,r)?(n(this,"isDirty",!1),n(this,"isPristine",!0)):(n(this,"isDirty",!0),n(this,"isPristine",!1))}_sortRecordsBy(s,e=[]){const t=D(e,r=>G(r.split(":"))),o=D(e,r=>ts(r.split(":")));return Cs(s,t,o)}_unloadFromCollection(s){const e=i(s,"collectionName"),t=g(this.collections[e],{hashId:i(s,"hashId")});b(t,0)&&this.collections[e].splice(t,1)}_unloadFromRequestHashes(s){const e=N(this.requestHashIds);l(e,t=>{const o=i(this.requestHashIds[t],"data"),r=y(o),a=I(o);if(r){const c=g(i(this.requestHashIds[t],"data"),{hashId:i(s,"hashId")});b(c,0)&&this.requestHashIds[t].data.splice(c,1)}a&&p(i(s,"hashId"),i(this.requestHashIds[t],"data.hashId"))&&n(this.requestHashIds[t],"data",{})})}_unloadFromAliases(s){const e=N(this.aliases);l(e,t=>{const o=y(this.aliases[t]),r=I(this.aliases[t]);if(o){const a=g(this.aliases[t],{hashId:i(s,"hashId")});b(a,0)&&this.aliases[t].splice(a,1)}r&&p(i(s,"hashId"),i(this.aliases[t],"hashId"))&&(this.aliases[t]={})})}unloadRecord(s){this._unloadFromCollection(s),this._unloadFromRequestHashes(s),this._unloadFromAliases(s)}_saveRecord(s){const e=i(s,"collectionName"),t=m(this.collections[e],{hashId:i(s,"hashId")}),o=z(i(t,"id")),r=o?i(t,"id"):null,u={resourceMethod:o?"put":"post",resourceName:e,resourceId:r,resourceParams:{},resourcePayload:{data:t},resourceFallback:{},resourceConfig:{}};return this._request(u)}async _deleteRecord(s,e={}){const t=i(s,"collectionName"),o=m(this.collections[t],{hashId:i(s,"hashId")}),r=i(s,"id"),h={resourceMethod:"delete",resourceName:i(o,"collectionName"),resourceId:Number(r),resourceParams:{},resourcePayload:null,resourceFallback:{},resourceConfig:e};return this._request(h)}async _reloadRecord(s){const e=i(s,"id"),r={resourceMethod:"get",resourceName:i(s,"collectionName"),resourceId:Number(e),resourceParams:{},resourcePayload:null,resourceFallback:{},resourceConfig:{skipId:L.v1()}};return this._request(r)}_getCollectionRecord(s,e={},t){const o=i(e,"referenceKey")||"",r=i(e,"async")||!1,a=i(e,"filterBy")||{},c=i(e,"sortBy")||[],h=i(t,o)||[],u=I(h),q=u?[h]:h,R=v([]);return l(q,T=>{const C=this._generateHashId({id:i(T,"id"),collectionName:s}),$=m(this.collections[s],{hashId:C});if(!w($))R.push($);else if(r){const P={resourceMethod:"get",resourceName:s,resourceId:i(T,"id"),resourceParams:{},resourcePayload:null,resourceFallback:{},resourceConfig:{}},V=J;this._pushRequestHash(P,V),this._request(P)}}),u?G(R):this._sortRecordsBy(es(R,a),c)}_injectCollectionActions(s){const e={get:this._getProperty,set:this._setProperty,setProperties:this._setProperties,save:()=>this._saveRecord(s),destroyRecord:o=>this._deleteRecord(s,o),reload:()=>this._reloadRecord(s),getCollection:(o,r)=>this._getCollectionRecord(o,r,s)},t=N(e);l(t,o=>{s[o]=e[o]})}_injectCollectionReferenceKeys(s,e,t=null){const o=ss(t)?this._generateHashId({id:i(e,"id"),collectionName:s}):t;n(e,"collectionName",s),n(e,"hashId",o),n(e,"isLoading",!1),n(e,"isError",!1),n(e,"isPristine",!0),n(e,"isDirty",!1)}_pushToCollection(s,e){const t=y(e),o=I(e);if(t){const r=D(e,"hashId");return l(e,a=>{const c=g(this.collections[s],{hashId:i(a,"hashId")});this._injectCollectionActions(a),U(c,0)&&this.collections[s].push(a),b(c,0)&&(this.collections[s][c]=a)}),D(r,a=>m(this.collections[s],{hashId:a}))}if(o){const r=e.hashId,a=g(this.collections[s],{hashId:i(e,"hashId")});return this._injectCollectionActions(e),U(a,0)&&this.collections[s].push(e),b(a,0)&&(this.collections[s][a]=e),m(this.collections[s],{hashId:r})}}_pushToAliases(s){const e=y(s),t=I(s),o=N(this.aliases);e&&l(o,r=>{const a=y(this.aliases[r]),c=I(this.aliases[r]);a&&l(s,h=>{const u=g(this.aliases[r],{hashId:i(h,"hashId")});b(u,0)&&(this.aliases[r][u]=h)}),c&&l(s,h=>{p(i(h,"hashId"),i(this.aliases[r],"hashId"))&&(this.aliases[r]=h)})}),t&&l(o,r=>{const a=y(this.aliases[r]),c=I(this.aliases[r]);a&&l([s],h=>{const u=g(this.aliases[r],{hashId:i(h,"hashId")});b(u,0)&&(this.aliases[r][u]=h)}),c&&p(i(s,"hashId"),i(this.aliases[r],"hashId"))&&(this.aliases[r]=s)})}_pushToRequestHashes(s){const e=N(this.requestHashIds),t=y(s),o=I(s);let r=null;t&&(r=s),o&&(r=[s]),l(e,a=>{const c=i(this.requestHashIds[a],"data"),h=y(c),u=I(c);l(r,q=>{if(h){const R=g(i(this.requestHashIds[a],"data"),{hashId:i(q,"hashId")});b(R,0)&&(this.requestHashIds[a].data[R]=q)}u&&p(i(q,"hashId"),i(this.requestHashIds[a],"data.hashId"))&&n(this.requestHashIds[a],"data",q)})})}_pushPayload(s,e){this._isCollectionExisting(s);const t=this._pushToCollection(s,e);return this._pushToAliases(t),this._pushToRequestHashes(t),t}_pushRequestHash(s={},e={isLoading:!0,isError:!1,isNew:!0,data:null}){const t=this._generateHashId(s),o=!_(this.requestHashIds[t]),r=i(e,"isNew");return o&&r?n(this.requestHashIds[t],"isNew",!1):this.requestHashIds[t]=e,this.requestHashIds[t]}setHost(s){this.host=s,this._initializeAxiosConfig()}setNamespace(s){this.namespace=s}setHeadersCommon(s,e){f.defaults.headers.common[`${s}`]=e}setPayloadIncludeReference(s){this.payloadIncludedReference=s}setGlobal(){typeof window<"u"&&(window.ARM=Object.freeze(this))}getCollection(s){return this.collections[s]||[]}clearCollection(s){this.collections[s]=[]}getAlias(s,e){return I(e)&&this._injectCollectionActions(e),this.aliases[s]||e}createRecord(s,e={},t=!0){const o=t?L.v1():L.NIL,r=_(m(this.collections[s],{id:o}));return n(e,"id",o),this._injectCollectionReferenceKeys(s,e),this._injectCollectionActions(e),r&&this.collections[s].push(e),m(this.collections[s],{id:o})}async _request({resourceMethod:s,resourceName:e,resourceId:t,resourceParams:o,resourcePayload:r,resourceFallback:a,resourceConfig:c}){var cs,hs,ds;const h={method:s,url:e},u=this._generateHashId({...arguments[0]}),q=p(s,"get"),R=p(s,"delete"),T=p(s,"post"),C=z(t)||_s(t),$=!w(o),P=!w(r),V=!_(i(c,"override")),B=i(r,"data")||null,W=C?m(this.collections[e],{id:t}):null;if(C&&n(h,"url",`${e}/${t}`),V){const d=i(c,"override")||{},j=_(i(d,"host"))?this.host:i(d,"host"),X=_(i(d,"namespace"))?this.namespace:i(d,"namespace"),Y=`${j}/${X}`,Z=_(i(d,"path"))?i(h,"url"):i(d,"path"),K=_(i(d,"headers"))?{}:i(d,"headers"),H=f.defaults.headers.common,S=gs(H,K);n(h,"baseURL",Y),n(h,"url",Z),n(h,"headers",S)}if($&&n(h,"params",o),P){const d={data:k(B,xs)};n(h,"data",d)}const Q=!_(i(c,"skip")),rs=p(i(c,"skip"),!0),os=this.requestHashIds[u],as=!_(os),ns=i(os,"isNew");if(!(q&&(Q&&rs||!Q&&as&&!ns||Q&&!rs&&as&&!ns))){P&&n(B,"isLoading",!0),C&&n(W,"isLoading",!0);try{const d=await f(h),j=((cs=d==null?void 0:d.data)==null?void 0:cs.data)||a,X=((hs=d==null?void 0:d.data)==null?void 0:hs.included)||[],Y=((ds=d==null?void 0:d.data)==null?void 0:ds.meta)||{},Z=I(j),K=y(j);let H=null,S=[];return K&&l(j,A=>this._injectCollectionReferenceKeys(e,A)),Z&&this._injectCollectionReferenceKeys(e,j),l(X,A=>{this._injectCollectionReferenceKeys(i(A,this.payloadIncludedReference),A),S.push(this._pushPayload(i(A,"collectionName"),A))}),H=await this._pushPayload(e,j),c.alias&&this._addAlias(i(c,"alias"),H),T&&this.unloadRecord(B),R&&this.unloadRecord(H),this.requestHashIds[u]={isLoading:!1,isError:!1,isNew:!1,data:H,included:S,meta:Y},Promise.resolve(H)}catch(d){return P&&(n(B,"isError",!0),n(B,"isLoading",!1)),C&&(n(W,"isError",!0),n(W,"isLoading",!1)),this.requestHashIds[u]={isLoading:!1,isError:!0,isNew:!1,data:d,included:[],meta:{}},Promise.reject(d)}}}query(s,e={},t={}){const o={resourceMethod:"get",resourceName:s,resourceId:null,resourceParams:e,resourcePayload:null,resourceFallback:[],resourceConfig:t},r=is,a=this._pushRequestHash(o,r);return this._request(o),a}queryRecord(s,e={},t={}){const o={resourceMethod:"get",resourceName:s,resourceId:null,resourceParams:e,resourcePayload:null,resourceFallback:{},resourceConfig:t},r=J,a=this._pushRequestHash(o,r);return this._request(o),a}findAll(s,e={}){const t={resourceMethod:"get",resourceName:s,resourceId:null,resourceParams:null,resourcePayload:null,resourceFallback:[],resourceConfig:e},o=is,r=this._pushRequestHash(t,o);return this._request(t),r}findRecord(s,e,t={},o={}){const r={resourceMethod:"get",resourceName:s,resourceId:e,resourceParams:t,resourcePayload:null,resourceFallback:{},resourceConfig:o},a=J,c=this._pushRequestHash(r,a);return this._request(r),c}peekAll(s){return this.collections[s]}peekRecord(s,e){return m(this.collections[s],{id:e})}ajax(s={}){return f.request(s)}findBy(s,e={}){return m(s,e)}findIndexBy(s,e={}){return g(s,e)}filterBy(s,e={}){return es(s,e)}uniqBy(s,e){return Ps(s,e)}groupBy(s,e){return As(s,e)}firstObject(s=[]){return G(s)}lastObject(s=[]){return ts(s)}mergeObjects(s=[],e=[]){return Os(js(s,e),p)}chunkObjects(s=[],e=1){return Hs(s,e)}sortBy(s,e){return this._sortRecordsBy(s,e)}isEmpty(s){return w(s)}isPresent(s){return!w(s)}isEqual(s,e){return p(s,e)}isNumber(s){return z(s)}isNil(s){return _(s)}isNull(s){return ss(s)}isGte(s,e){return b(s,e)}isGt(s,e){return qs(s,e)}isLte(s,e){return ms(s,e)}isLt(s,e){return U(s,e)}}return ws});
