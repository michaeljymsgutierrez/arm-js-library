(function(f,v){typeof exports=="object"&&typeof module<"u"?module.exports=v(require("axios"),require("lodash"),require("mobx"),require("uuid"),require("crypto-js")):typeof define=="function"&&define.amd?define(["axios","lodash","mobx","uuid","crypto-js"],v):(f=typeof globalThis<"u"?globalThis:f||self,f["arm-js-library"]=v(f.axios,f._,f.mobx,f.uuid,f.CryptoJS))})(this,function(f,v,ls,k,fs){"use strict";function ps(O){const s=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(O){for(const e in O)if(e!=="default"){const t=Object.getOwnPropertyDescriptor(O,e);Object.defineProperty(s,e,t.get?t:{enumerable:!0,get:()=>O[e]})}}return s.default=O,Object.freeze(s)}const Is=ps(ls);/**
 * ARM JavaScript Library
 *
 * Version: 1.5.3
 * Date: 2024-05-09 2:19PM GMT+8
 *
 * @author Michael Jyms Gutierrez
 * @license MIT
 *
 * Axios library for making HTTP requests.
 * @see https://axios-http.com/docs/
 *
 * Lodash utility library.
 * @see https://lodash.com/docs/4.17.21
 *
 * MobX state management library.
 * @see https://mobx.js.org/
 *
 * UUID generation library.
 * @see https://www.npmjs.com/package/uuid
 *
 * CryptoJS library for cryptographic functions.
 * @see https://crypto-js.org/
 */const{makeObservable:Rs,observable:L,action:D,toJS:E}=Is,{get:i,set:h,find:q,findIndex:y,isObject:_s,isArray:_,isPlainObject:R,isNumber:z,isString:qs,isNull:ss,isNil:p,isEmpty:x,isEqual:I,gte:m,gt:ys,lte:ms,lt:U,assign:gs,flatMap:bs,map:F,entries:Hs,forEach:l,filter:es,keysIn:w,concat:js,chunk:Os,uniqWith:Ps,omit:B,first:G,last:ts,orderBy:Cs,uniqBy:As,groupBy:vs}=v,is={isLoading:!0,isError:!1,isNew:!0,data:[],error:null,included:[],meta:{}},X={isLoading:!0,isError:!1,isNew:!0,data:{},error:null,included:[],meta:{}},M=["destroyRecord","getCollection","reload","save","set","get","setProperties","isDirty","isError","isLoading","isPristine"],xs=["destroyRecord","getCollection","reload","save","set","get","setProperties","isDirty","isError","isLoading","isPristine","hashId","collectionName"];class ws{constructor(s=[]){this.namespace="api/v1",this.host=typeof window<"u"?window.location.origin:"",this.collections={},this.aliases={},this.requestHashIds={},this.payloadIncludedReference="type",this._initializeCollections(s),this._initializeAxiosConfig(),Rs(this,{collections:L,aliases:L,requestHashIds:L,_pushPayload:D,_pushRequestHash:D,_addCollection:D,_addAlias:D})}_initializeAxiosConfig(){f.defaults.baseURL=this._getBaseURL()}_initializeCollections(s){l(s,e=>this._addCollection(e,[]))}_getBaseURL(){return`${this.host}/${this.namespace}`}_isCollectionExisting(s){if(p(i(this.collections,s)))throw`Collection ${s} does not exist.
Fix: Try adding ${s} on your ARM config initialization.`}_addCollection(s,e){this.collections[s]=e}_addAlias(s,e){const t=_(e),o=R(e);t&&(this.aliases[s]=e||[]),o&&(this.aliases[s]=e||{})}_generateHashId(s={id:k.v1()}){const e=JSON.stringify(s);return fs.MD5(e).toString()}_setProperties(s,e){function t(r,a=""){return bs(Hs(r),([n,c])=>{const d=a?`${a}.${n}`:n;return _s(c)&&!_(c)&&c!==null?t(c,d):{key:d,value:c}})}const o=t(e);l(o,({key:r,value:a})=>h(s,r,a))}_getRecordProperty(s){return i(this,s)}_setRecordProperty(s,e){h(this,s,e);const t=B(E(this.originalRecord),M),o=B(E(this),M);I(t,o)?(h(this,"isDirty",!1),h(this,"isPristine",!0)):(h(this,"isDirty",!0),h(this,"isPristine",!1))}_setRecordProperties(s){this._setProperties(this,s);const e=B(E(this.originalRecord),M),t=B(E(this),M);I(e,t)?(h(this,"isDirty",!1),h(this,"isPristine",!0)):(h(this,"isDirty",!0),h(this,"isPristine",!1))}_sortRecordsBy(s,e=[]){const t=F(e,r=>G(r.split(":"))),o=F(e,r=>ts(r.split(":")));return Cs(s,t,o)}_unloadFromCollection(s){const e=i(s,"collectionName"),t=y(this.collections[e],{hashId:i(s,"hashId")});m(t,0)&&this.collections[e].splice(t,1)}_unloadFromRequestHashes(s){const e=w(this.requestHashIds);l(e,t=>{const o=i(this.requestHashIds[t],"data"),r=_(o),a=R(o);if(r){const n=y(i(this.requestHashIds[t],"data"),{hashId:i(s,"hashId")});m(n,0)&&this.requestHashIds[t].data.splice(n,1)}a&&I(i(s,"hashId"),i(this.requestHashIds[t],"data.hashId"))&&h(this.requestHashIds[t],"data",{})})}_unloadFromAliases(s){const e=w(this.aliases);l(e,t=>{const o=_(this.aliases[t]),r=R(this.aliases[t]);if(o){const a=y(this.aliases[t],{hashId:i(s,"hashId")});m(a,0)&&this.aliases[t].splice(a,1)}r&&I(i(s,"hashId"),i(this.aliases[t],"hashId"))&&(this.aliases[t]={})})}unloadRecord(s){this._unloadFromCollection(s),this._unloadFromRequestHashes(s),this._unloadFromAliases(s)}_saveRecord(s){const e=i(s,"collectionName"),t=q(this.collections[e],{hashId:i(s,"hashId")}),o=z(i(t,"id")),r=o?i(t,"id"):null,d={resourceMethod:o?"put":"post",resourceName:e,resourceId:r,resourceParams:{},resourcePayload:{data:t},resourceFallback:{},resourceConfig:{autoResolveOrigin:"_internal"}};return this._request(d)}async _deleteRecord(s,e={}){const t=i(s,"collectionName"),o=q(this.collections[t],{hashId:i(s,"hashId")}),r=i(s,"id"),a=i(o,"collectionName"),n="delete";h(e,"autoResolveOrigin","_internal");const c={resourceMethod:n,resourceName:a,resourceId:Number(r),resourceParams:{},resourcePayload:null,resourceFallback:{},resourceConfig:e};return this._request(c)}async _reloadRecord(s){const e=i(s,"id"),r={resourceMethod:"get",resourceName:i(s,"collectionName"),resourceId:Number(e),resourceParams:{},resourcePayload:null,resourceFallback:{},resourceConfig:{skipId:k.v1(),autoResolveOrigin:"_internal"}};return this._request(r)}_getCollectionRecord(s,e={},t){const o=i(e,"referenceKey")||"",r=i(e,"async")||!1,a=i(e,"filterBy")||{},n=i(e,"sortBy")||[],c=i(t,o)||[],d=R(c),g=d?[c]:c,b=L([]);return l(g,T=>{const P=this._generateHashId({id:i(T,"id"),collectionName:s}),$=q(this.collections[s],{hashId:P});if(!x($))b.push($);else if(r){const C={resourceMethod:"get",resourceName:s,resourceId:i(T,"id"),resourceParams:{},resourcePayload:null,resourceFallback:{},resourceConfig:{}},J=X;this._pushRequestHash(C,J),this._request(C)}}),d?G(b):this._sortRecordsBy(es(b,a),n)}_injectCollectionActions(s){const e={get:this._getRecordProperty,set:this._setRecordProperty,setProperties:this._setRecordProperties,save:()=>this._saveRecord(s),destroyRecord:o=>this._deleteRecord(s,o),reload:()=>this._reloadRecord(s),getCollection:(o,r)=>this._getCollectionRecord(o,r,s)},t=w(e);l(t,o=>{s[o]=e[o]})}_injectCollectionReferenceKeys(s,e,t=null){const o=ss(t)?this._generateHashId({id:i(e,"id"),collectionName:s}):t;h(e,"collectionName",s),h(e,"hashId",o),h(e,"isLoading",!1),h(e,"isError",!1),h(e,"isPristine",!0),h(e,"isDirty",!1)}_pushToCollection(s,e){const t=_(e),o=R(e);if(t){const r=F(e,"hashId");return l(e,a=>{const n=y(this.collections[s],{hashId:i(a,"hashId")});this._injectCollectionActions(a),U(n,0)&&this.collections[s].push(a),m(n,0)&&(this.collections[s][n]=a)}),F(r,a=>q(this.collections[s],{hashId:a}))}if(o){const r=e.hashId,a=y(this.collections[s],{hashId:i(e,"hashId")});return this._injectCollectionActions(e),U(a,0)&&this.collections[s].push(e),m(a,0)&&(this.collections[s][a]=e),q(this.collections[s],{hashId:r})}}_pushToAliases(s){const e=_(s),t=R(s),o=w(this.aliases);e&&l(o,r=>{const a=_(this.aliases[r]),n=R(this.aliases[r]);a&&l(s,c=>{const d=y(this.aliases[r],{hashId:i(c,"hashId")});m(d,0)&&(this.aliases[r][d]=c)}),n&&l(s,c=>{I(i(c,"hashId"),i(this.aliases[r],"hashId"))&&(this.aliases[r]=c)})}),t&&l(o,r=>{const a=_(this.aliases[r]),n=R(this.aliases[r]);a&&l([s],c=>{const d=y(this.aliases[r],{hashId:i(c,"hashId")});m(d,0)&&(this.aliases[r][d]=c)}),n&&I(i(s,"hashId"),i(this.aliases[r],"hashId"))&&(this.aliases[r]=s)})}_pushToRequestHashes(s){const e=w(this.requestHashIds),t=_(s),o=R(s);let r=null;t&&(r=s),o&&(r=[s]),l(e,a=>{const n=i(this.requestHashIds[a],"data"),c=_(n),d=R(n);l(r,g=>{if(c){const b=y(i(this.requestHashIds[a],"data"),{hashId:i(g,"hashId")});m(b,0)&&(this.requestHashIds[a].data[b]=g)}d&&I(i(g,"hashId"),i(this.requestHashIds[a],"data.hashId"))&&h(this.requestHashIds[a],"data",g)})})}_pushPayload(s,e){this._isCollectionExisting(s);const t=this._pushToCollection(s,e);return this._pushToAliases(t),this._pushToRequestHashes(t),t}_pushRequestHash(s,e){const t=this._generateHashId(s),o=!p(this.requestHashIds[t]),r=i(e,"isNew");return o&&r?h(this.requestHashIds[t],"isNew",!1):this.requestHashIds[t]=e,this.requestHashIds[t]}setHost(s){this.host=s,this._initializeAxiosConfig()}setNamespace(s){this.namespace=s}setHeadersCommon(s,e){f.defaults.headers.common[`${s}`]=e}setPayloadIncludeReference(s){this.payloadIncludedReference=s}setGlobal(){typeof window<"u"&&(window.ARM=Object.freeze(this))}getCollection(s){return this.collections[s]||[]}clearCollection(s){this.collections[s]=[]}getAlias(s,e){return R(e)&&this._injectCollectionActions(e),this.aliases[s]||e}createRecord(s,e={},t=!0){const o=t?k.v1():k.NIL,r=p(q(this.collections[s],{id:o}));return h(e,"id",o),this._injectCollectionReferenceKeys(s,e),this._injectCollectionActions(e),r&&this.collections[s].push(e),q(this.collections[s],{id:o})}_resolveRequest(s,e,t){return(!p(i(s,"autoResolve"))?i(s,"autoResolve"):!0)?t:e}async _request({resourceMethod:s,resourceName:e,resourceId:t,resourceParams:o,resourcePayload:r,resourceFallback:a,resourceConfig:n}){var hs,us,ds;const c={method:s,url:e},d=this._generateHashId({...arguments[0]}),g=I(s,"get"),b=I(s,"delete"),T=I(s,"post"),P=z(t)||qs(t),$=!x(o),C=!x(r),J=!p(i(n,"override")),N=i(r,"data")||null,V=P?q(this.collections[e],{id:t}):null,rs=!p(i(n,"autoResolveOrigin"));if(P&&h(c,"url",`${e}/${t}`),J){const u=i(n,"override")||{},H=p(i(u,"host"))?this.host:i(u,"host"),Q=p(i(u,"namespace"))?this.namespace:i(u,"namespace"),Y=`${H}/${Q}`,Z=p(i(u,"path"))?i(c,"url"):i(u,"path"),K=p(i(u,"headers"))?{}:i(u,"headers"),j=f.defaults.headers.common,S=gs(j,K);h(c,"baseURL",Y),h(c,"url",Z),h(c,"headers",S)}if($&&h(c,"params",o),C){const u={data:B(N,xs)};h(c,"data",u)}const W=!p(i(n,"skip")),os=I(i(n,"skip"),!0),as=this.requestHashIds[d],ns=!p(as),cs=i(as,"isNew");if(!(g&&(W&&os||!W&&ns&&!cs||W&&!os&&ns&&!cs))){C&&h(N,"isLoading",!0),P&&h(V,"isLoading",!0);try{const u=await f(c),H=((hs=u==null?void 0:u.data)==null?void 0:hs.data)||a,Q=((us=u==null?void 0:u.data)==null?void 0:us.included)||[],Y=((ds=u==null?void 0:u.data)==null?void 0:ds.meta)||{},Z=R(H),K=_(H);let j=null,S=[];return K&&l(H,A=>this._injectCollectionReferenceKeys(e,A)),Z&&this._injectCollectionReferenceKeys(e,H),l(Q,A=>{this._injectCollectionReferenceKeys(i(A,this.payloadIncludedReference),A),S.push(this._pushPayload(i(A,"collectionName"),A))}),j=await this._pushPayload(e,H),n.alias&&this._addAlias(i(n,"alias"),j),T&&this.unloadRecord(N),b&&this.unloadRecord(j),this.requestHashIds[d]={isLoading:!1,isError:!1,isNew:!1,data:j,error:null,included:S,meta:Y},rs?Promise.resolve(j):Promise.resolve(this.requestHashIds[d])}catch(u){return C&&(h(N,"isError",!0),h(N,"isLoading",!1)),P&&(h(V,"isError",!0),h(V,"isLoading",!1)),this.requestHashIds[d]={isLoading:!1,isError:!0,isNew:!1,data:a,error:u,included:[],meta:{}},rs?Promise.reject(u):Promise.reject(this.requestHashIds[d])}}}query(s,e={},t={}){const o={resourceMethod:"get",resourceName:s,resourceId:null,resourceParams:e,resourcePayload:null,resourceFallback:[],resourceConfig:t},r=is,a=this._pushRequestHash(o,r),n=this._request(o);return this._resolveRequest(t,n,a)}queryRecord(s,e={},t={}){const o={resourceMethod:"get",resourceName:s,resourceId:null,resourceParams:e,resourcePayload:null,resourceFallback:{},resourceConfig:t},r=X,a=this._pushRequestHash(o,r),n=this._request(o);return this._resolveRequest(t,n,a)}findAll(s,e={}){const t={resourceMethod:"get",resourceName:s,resourceId:null,resourceParams:null,resourcePayload:null,resourceFallback:[],resourceConfig:e},o=is,r=this._pushRequestHash(t,o),a=this._request(t);return this._resolveRequest(e,a,r)}findRecord(s,e,t={},o={}){const r={resourceMethod:"get",resourceName:s,resourceId:e,resourceParams:t,resourcePayload:null,resourceFallback:{},resourceConfig:o},a=X,n=this._pushRequestHash(r,a),c=this._request(r);return this._resolveRequest(o,c,n)}peekAll(s){return this.collections[s]}peekRecord(s,e){return q(this.collections[s],{id:e})}ajax(s={}){return f.request(s)}findBy(s,e={}){return q(s,e)}findIndexBy(s,e={}){return y(s,e)}filterBy(s,e={}){return es(s,e)}uniqBy(s,e){return As(s,e)}groupBy(s,e){return vs(s,e)}firstObject(s=[]){return G(s)}lastObject(s=[]){return ts(s)}mergeObjects(s=[],e=[]){return Ps(js(s,e),I)}chunkObjects(s=[],e=1){return Os(s,e)}sortBy(s,e){return this._sortRecordsBy(s,e)}isEmpty(s){return x(s)}isPresent(s){return!x(s)}isEqual(s,e){return I(s,e)}isNumber(s){return z(s)}isNil(s){return p(s)}isNull(s){return ss(s)}isGte(s,e){return m(s,e)}isGt(s,e){return ys(s,e)}isLte(s,e){return ms(s,e)}isLt(s,e){return U(s,e)}}return ws});
